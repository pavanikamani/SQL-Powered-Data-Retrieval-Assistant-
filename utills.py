"""
utills.py

Purpose:
--------
This module contains backend utility functions used by the main Streamlit application.

Structure:
----------
1️⃣ Import required libraries
2️⃣ Define three independent core functions:
    - get_db_schema()
    - call_euri_llm()
    - execute_sql()

These functions are modular and independent in logic,
but are orchestrated together inside app.py.

This separation ensures:
✔ Clean architecture
✔ Better modularity
✔ Reusability
✔ Easier debugging
"""

# ======================================================
# Required Imports
# ======================================================

import requests  # Used to call EURI LLM API
from sqlalchemy import text, MetaData  # Used for database interaction
from config import EURI_API_KEY, EURI_API_URL, MODEL_NAME  # Configuration variables


# ======================================================
# FUNCTION 1: Extract Database Schema
# ======================================================

def get_db_schema(engine):
    """
    Dynamically retrieves database schema information
    including table names and column types.

    Parameters:
        engine (SQLAlchemy Engine): Active database connection engine

    Returns:
        str: Formatted schema string used in LLM prompt
    """

    meta = MetaData()
    meta.reflect(bind=engine)

    schema = ""

    for table in meta.tables.values():
        schema += (
            f"\nTable: {table.name}\n"
            f"Columns: {', '.join([col.name + ' (' + str(col.type) + ')' for col in table.columns])}\n"
        )

    return schema.strip()


# ======================================================
# FUNCTION 2: Call EURI LLM API
# ======================================================

def call_euri_llm(prompt):
    """
    Sends formatted prompt to EURI LLM API
    and retrieves the generated SQL query.

    Parameters:
        prompt (str): Prompt containing schema + user question

    Returns:
        str: Generated SQL query
    """

    headers = {
        "Authorization": f"Bearer {EURI_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": MODEL_NAME,
        "messages": [
            {
                "role": "user",
                "content": prompt
            }
        ],
        "temperature": 0.3,
        "max_tokens": 300
    }

    # Make API request
    response = requests.post(EURI_API_URL, headers=headers, json=payload)

    # Raise error if API fails
    response.raise_for_status()

    data = response.json()

    content = data["choices"][0]["message"]["content"]

    # Case 1: If API returns plain string
    if isinstance(content, str):
        return content.strip()

    # Case 2: If API returns structured list (rich response format)
    if isinstance(content, list) and len(content) > 0:
        return content[0].get("text", "").strip()

    # Fallback safety check
    raise ValueError(f"Unexpected EURI response format: {content}")


# ======================================================
# FUNCTION 3: Execute SQL Query
# ======================================================

def execute_sql(engine, query):
    """
    Executes generated SQL query on the database.

    Parameters:
        engine (SQLAlchemy Engine): Active DB connection
        query (str): SQL query generated by LLM

    Returns:
        tuple:
            - List of result rows
            - Column names
    """

    with engine.connect() as conn:
        result = conn.execute(text(query))
        return result.fetchall(), result.keys()
